import UIKit

// 1. Чему будут равны выражения? И какой тип будет у констант?

let a = Double(2) / Int(3) // Ответ: Нельзя производить действия с разными типами данных. Они должны быть одного типа либо должны быть приведены к одному типу. Операция совершится с ошибкой соответственно у константы не будет типа.

let b = 13.0 / 5 // Ответ: Выражение равно 2.6. В данном случае константа b объявлена как результат деления литерала с плавающей точкой с целыми литералом, поэтому у константы будет тип Double.

let c = a + b // Ответ: Нельзя производить действия с разными типами данных. Они должны быть одного типа либо должны быть приведены к одному типу. Операция совершится с ошибкой соответственно у константы не будет типа.

let d = "iOS" + " and " + "Android" // Ответ: Выполняется конкатенация трех строковых литералов. Выражение равно "iOS and Android". Тип данных String.

let e: Int8 = 1000 // Ответ: Тип данных Int8 может хранить числа между -128 и 127, а 1000 не входит в этот диапазон. Операция совершится с ошибкой соответственно у константы не будет типа.

let f = Int("900.0") // Ответ: В приведенном примере используется метод Int() для попытки преобразовать String в Int. Т.к. метод Int() может иметь недопустимый аргумент он возвращает опционал. Выражение равно nil. Константа f является Опционалом.

let g = Double("-90.9") // Ответ: Производится преобразование строкового литерала в тип Double, так как строковый литерал имеет допустимый аргумент то выражение равно -90.90000000000001. Т.к. метод Double() может иметь недопустимый аргумент он возвращает опционал. Константа g является Опционалом.

let h: UInt = -10000 // Ответ: Тип данных UInt является беззнаковым типом целого числа, а -10000 не входит в этот диапазон. Операция совершится с ошибкой соответственно у константы не будет типа.

let j = 30 % 2 // Ответ: Результатом является остаток от деления 30 на 2, равный 0. У константы j тип Int.

let k = 156 % 27 // Ответ: Результатом является остаток от деления 160 на 27, равный 21. У константы k тип Int.

let l = 20.3.truncatingRemainder(dividingBy: 8) //  Ответ: Выражение truncatingRemainder(dividingBy: 8) позволяет определить, делится ли 20.3 без остатка на 8. Результат равен 4.300000000000001. Константа l имеет тип Double.

let m = 206.8.truncatingRemainder(dividingBy: 95.4) // Ответ: Результат равен 16. Константа имеет тип Double.

let n = (20, 4) // Ответ: В данном примере это кортеж, результат (.0 20, .1 4). Константа n равна кортежу типа (Int, Int)

let o = n.0 / n.1 // Ответ: Первый элемент предыдущего кортежа делится на второй элемент 20 / 4 = 5. Тип константы o = Int

let p = (iOS: "iOS", android: "Android", iOSV: 13.4, androidV: 30) // Ответ: (iOS "iOS", android "Android", iOSV 13.4, androidV 30). Константа p равна кортежу типа (String, String, Double, Int)

let q = "\(p.iOS) v. \(p.iOSV), \(p.android) v. \(p.androidV)" // Ответ: Берет значения предыдущего кортежа и вставляет значения по названию элементов в строку. Результат "iOS v. 13.4, Android v. 30". Тип константы q равен String.

let r = 5.0 / 0 // Ответ: Выводится результат inf (машинная бесконечность) - это результат деления на ноль. Тип константы r равен Double

let s = 5 / 0 // Ответ: Попытка целочисленного деления на ноль является критической ошибкой. Операция совершится с ошибкой соответственно у константы не будет типа.

//2. Создать 4 константы и присвоить им число (целое или с плавающей точкой), записаное в десятичной, двоичной, восьмиричной и шестандцатиричной системе счисления соответственно.

let first = 4 // десятичная
let second = 0b100 // двоичная
let third = 0o4 // восьмеричная
let fourth = 0x4 // шестнадцатеричная

// 3. Прочитать про базовые операторы в swift https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html

// Ответ: Прочитано

// 4. Привести по два примера с использованием неизвестных ранее операторов.

2 + 2 == 4 // Результат: true
4 < 2 // Результат: false

//5. Что произойдет в результате выполнения следующего кода:

let max = Int(String(Int.max))! // Максимальное значение типа Int сначала преобразуется в строку, затем принудительно извлекается значение из опционала Int(). В результате max присваивается максимальному значению типа Int и имеет тип Int.

let overflow = max + 1  // Ответ: Так как max имеет максимальное значение типа Int, попытка добавить число 1 завершится с критической ошибкой.
